1. 基本类型：bool
2. 函数形参设置默认值，而且参数是从右到左入栈，所以有默认值的必须在右边
3. 函数重载，函数名称相同，但参数列表不同，即参数类型或个数不同
4. 函数模板template<class 类型1，class 类型2>
返回值 函数名（形参表列） 模板参数表

{

   函数体

}

例子：
#include<iostream>
using namespace std;
template<class T1,class T2>
T1 add(T1 x,T2 y)
{
    cout<<sizeof(T1)<<","<<sizeof(T2)<<"\t";
    return x+y;
}
int main()
{
    cout<<add(10,20)<<endl;;
    cout<<add(3.14,5.98)<<endl;
    cout<<add('A',2)<<endl;
    return 0;
}

5. inline内联函数，对于简短简单的函数，声明是inline的，编译阶段会把函数代码替换到对于的位置，减少函数调用的开销（这只是一个需求，但具体会不会实现，还得看编译器）
6. 类的定义class，public private protect 成员访问权限，类定义的最后有“;”
7.引用类型，对象的别名
8.构造函数，构造函数可以重载，一旦自定义就不会自动创建空的默认构造函数
9.析构函数不可重载
10.拷贝构造函数，解决成员中存在指针类型时的释放，即多次回收同一块内存，实现深拷贝

11.c++静态绑定，在编译阶段根据变量的类型决定调用对应的方法
12. 虚函数 virtual int getName();在运行时确定调用的类型，属于动态联编（多态）
13. 通常将析构函数定义为虚函数，用基类的指针指向派生类的对象在释放时，可以根据实际所指向的对象类型动态联编调用子类的析构函数，实现正确的对象内存释放。（多态）
14. 纯虚函数： virtual 返回值  函数名（形参）=0; =0表示没有函数体
 
//////

c中结构体占位计算，对齐规则：
1. 每一位的起始地址是当前变量位长的整数倍
2. 结构体的总位长是结构体中最长的变量的位数的整数倍，不够则补齐
